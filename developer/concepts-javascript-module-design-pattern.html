
---
title: '자바스크립트 모듈 디자인 패턴'
parent: Developers
---
<article class="bcls-article">
  <h1>개념: 자바스크립트 모듈 디자인 패턴</h1>
  <summary>이 항목에서는 JavaScript 모듈 디자인 패턴을 사용하여 코드가 웹 페이지의 다른 스크립트와 충돌 할 가능성을 줄이는 방법을 배웁니다.</summary>
  <section class="bcls-section">
    <h2 id="Scope_conflicts">범위 충돌</h2>
    <p>JavaScript에서<code translate="No">var</code>요소를 사용하여 변수를 정의하면 정의된 함수 내에서 범위가 지정됩니다. 를 사용하지 않고 변수를<code translate="No">var</code>정의하면 전역 범위가 할당됩니다. 이는 전역 변수가 페이지의 다른 스크립트와의 충돌에 취약하다는 것을 의미합니다.</p>
    <p>코드 예제를 살펴 보겠습니다. 다음 코드에서 함수와 변수는 페이지 범위 내에 있습니다.</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">// script 1
var incrementCount = function() {
    count++;
}

var myButton = document.getElementById('buttonId');
var count = 0;

myButton.onclick = incrementCount;</code></pre>
    <p>이제 스크립트 외부에 전역<code translate="No">count</code>변수를 수정하는 함수가 있다고 가정해 보겠습니다. 이러한 스크립트 충돌로 인해 예기치 않은 결과가 발생할 수 있습니다.</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">// script 2
var countVideos = function(videoList) {
    count = videoList.length;
}</code></pre>
    <p>결과:</p>
    <ol>
      <li>사용자가<code translate="No">myButton</code>버튼을 두 번 선택하여<code translate="No">count</code>변수를 증가시킵니다. <code translate="No">script 1</code> .
        <ul>
          <li><code translate="No">count</code> = <strong> 2</strong></li>
        </ul>
      </li>
      <li>이<code translate="No">countvideos</code>함수는 호출되며 웹 페이지에도 존재합니다<code translate="No">Script 2</code> . 에<code translate="No">videoList</code> 10개의 항목이 포함되어 있다고 가정해 보겠습니다. 이제<code translate="No">count</code>전역 변수의 값은<strong></strong> 10입니다.
        <ul>
          <li><code translate="No">count</code> = <strong> 10</strong></li>
        </ul>
      </li>
      <li>다음에 사용자가<code translate="No">myButton</code>버튼을 선택하면<code translate="No">count</code>변수가 예상치 못한 결과를 반환합니다.
        <ul>
          <li>예상: <code translate="No">count</code> = <strong> 3</strong></li>
          <li>실제: <code translate="No">count</code> = <strong> 11</strong></li>
        </ul>
      </li>
    </ol>
    <p>스크립트에서 충돌을 피하려고 할 수 있지만 페이지에 포함 된 타사 스크립트가 유사한 함수 및 변수 이름을 사용하지 않는다는 보장은 없습니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Anonymous_functions">익명 기능</h2>
    <p>한 가지 해결책은 즉시 실행되는 익명 함수 (클로저라고도 함)로 코드를 래핑하는 것입니다. 클로저 내의 코드는 다른 스크립트에서 액세스 할 수 없습니다. 따라서 이것은 개인 함수와 변수를 생성하는 방법을 제공합니다.</p>
    <p>다음은 익명 함수의 구문입니다.</p>
    <ul>
      <li>행 3: 다른 코드가 함수를 호출하기를 기다리는 대신 JavaScript가 구문 분석 후 즉시 함수를 실행하도록 지시하는 추가 괄호 집합을 포함합니다.</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">(function () {
    // your code
}<span class="bcls-highlight">()</span>);</code></pre>
    <p>클로저는 애플리케이션의 수명 내내 프라이버시와 상태를 제공하므로 강력 할 수 있습니다. 클로저 내부 코드의 경우 모든 변수와 함수는 클로저 범위에만 있습니다. 그러나 클로저 내부의 코드는 여전히 모든 전역 변수 또는 함수에 액세스 할 수 있습니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Globals">글로벌</h2>
    <p>JavaScript에는 묵시적 전역이라는 기능이 있지만 전역 변수를 결정하기가 쉽지 않기 때문에 코드를 관리하기 어려울 수 있습니다. 변수가 전역인지 확인하려면 인터프리터는 이름과 일치하는<code translate="No">var</code>문을 찾는 범위 체인을 거꾸로 거꾸로 이동해야 합니다. 아무것도 발견되지 않으면 변수는 전역으로 간주됩니다.</p>
    <h3>글로벌 전달</h3>
    <p>익명 함수를 사용하면 전역 매개 변수를 명시 적으로 전달할 수 있습니다. 이를 코드로 매개 변수 가져 오기라고합니다.</p>
    <p>다음은 그 예입니다.</p>
    <ul>
      <li>라인 1: 함수에 전달되는 매개 변수의 이름을 정의합니다. 3 행의 이름과 일치 할 필요는 없습니다. 여기서<code translate="No">window</code>객체는 라는 매개 변수로 전달됩니다<code translate="No">window1</code> .</li>
      <li>3행: <code translate="No">window</code>객체를 함수에 전달합니다.</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">(function( window1, undefined ) {
    ...
})(window);</code></pre>
    <p>전달되는 객체가 하나만 있지만 두 개의 매개 변수가 있으므로 의 값은<code translate="No">undefined</code>정의되지 않습니다.</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">typeof undefined == "undefined"</code></pre>
    <p>다른 변수가 정의되어 있는지 쉽게 확인할 수있는 방법을 원할 때 유용 할 수 있습니다.</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">if(variable1 === undefined)</code></pre>
    <h3>글로벌 수출</h3>
    <p>익명 함수 외부에 변수와 함수를 전달할 수도 있습니다. <code translate="No">return</code>값을 사용하여 이 작업을 수행할 수 있습니다.</p>
    <p>다음은 그 예입니다.</p>
    <ul>
      <li>라인 1: 익명 함수를 에<code translate="No">BCLS</code>할당합니다. 이 값은 선택하는 모든 것이 될 수 있습니다. 이 예에서는 BCLS (Brightcove Learning Services)를 사용하고 있습니다.</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = (function( window1, undefined ) {
    var object1 = {};
    object1.count = 1;
    object1.method = function () {
        ...
    }
    <span class="bcls-highlight">return object1;</span>
})(window);</code></pre>
    <p>이제<code translate="No">object1</code>객체는 두 개의 공용 속성, 즉 이름이 지정된<code translate="No">count</code>변수와 이름이 지정된 함수를 사용하여 전역적으로 사용할 수 있습니다. <code translate="No">method</code> . 익명 기능 외부에서 다음과 같이 액세스 할 수 있습니다.</p>
    <ul>
      <li><code translate="No">BCLS.object1.count</code></li>
      <li><code translate="No">BCLS.object1.method</code></li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Complete_example">완전한 예</h2>
    <p>다음은 JavaScript 모듈 디자인 패턴의 전체 예제입니다.</p>
    <h3>예 1</h3>
    <p>이 예제는 모듈 패턴을 사용하여 개인 및 공용 변수 및 함수를 작성하는 방법을 보여줍니다.</p>
    <ul>
      <li>비공개 변수: <code translate="No">myvar</code> , <code translate="No">myvar2</code></li>
      <li>개인 기능: <code translate="No">fname</code> , <code translate="No">fname2</code></li>
      <li>공용 변수: <code translate="No">myvar3</code></li>
      <li>공개 기능: <code translate="No">fname3</code></li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = ( function() {
   var myvar = value,
       myvar2 = value;

   fname = function() {
        ...
   };
   fname2 = function() {
        ...
   };

   return {
        fname3 : function() {
             ...
        },
        myvar3 = value;
   };
}());</code></pre>
    <h3>예 2</h3>
    <p>이 예제는 전역 개체를 전달하고 공용 함수를 노출합니다.</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = (function( window, document, videojs ) {
    var myvar = value;

    // use a global object passed into the anonymous function
    videojs.registerPlugin('overlay');

    fname = function() {
        ...
    }
    return {
      fname2 : function() {
            ...
        }
    }
})(window, document, videojs);

// call the public function fname2
var newvar = BCLS.fname2();</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Code_samples">코드 샘플</h2>
    <p>일부 코드 예제는 JavaScript 모듈 디자인 패턴을 사용하며이 패턴을 구현하는 방법에 대한 아이디어를 검토 할 수 있습니다.</p>
    <ul>
      <li><a href="https://player.support.brightcove.com/code-samples/brightcove-player-sample-floating-player.html">플로팅 플레이어</a></li>
    </ul>
  </section>
</article>